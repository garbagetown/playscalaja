h1. プロジェクト立ち上げ

h2. <a>はじめに</a>

このチュートリアルでは、Scala言語を使って、Playフレームワークベースのアプリケーションの開発を一通り学習することができます。このアプリでは、Playアプリケーション開発の実践を通して、実際のプロジェクトで必要とされるであろう、全てのことを試すことができます。

このチュートリアルはいくつかの独立した章に分割しています。それぞれの章で、実際のプロジェクトで必要とされる、バリデーションや、エラーハンドリング、セキュリテリ対策、自動テスト、WEB画面、管理領域などの、より複雑な機能を紹介しています。

p(note). このチュートリアル内の **全てのソースコード** は、実際のプロジェクトで使ってもらって構いません。どんどんコードスニペットをコピペしたり、まるまる盗んだりしてください。

h2. <a>プロジェクト</a>

チュートリアルのプロジェクとして、「yet another blog engine（ちょっと気の利いたブログエンジン）」を選択しました。あまり想像力に富んだ選択とは言えないけど、今どきのWEBアプリに求められているほとんどの機能を紹介することができます。

編集者や管理者といったいくつかの違う権限ユーザを管理することで、このブログエンジンをより面白くすることができます。

このブログエンジンプロジェクトを **yabe** と呼ぶことにします。

!images/guide1-0!

p(note). このチュートリアルは、サンプルアプリケーションとして提供されています。ソースコードは、Scalaモジュールがインストールされているディレクトリの、 **samples-and-tests/yabe/** 配下にあります。

h2. <a>Play frameworkのインストール</a>

インストールはとても簡単です。ダウンロードページからバイナリパッケージをダウンロードして、それを解凍して適当なところに配置してください。Scalaモジュールは、Playフレームワークのバージョン *1.2* 以上からのみに対応となりますので、気をつけてください。

p(note). Windowsの場合は、 **c:\Documents And Settings\user\play** のように、パスの中にスペース文字を含めず、 **c:\play** とした方が賢明です。

効率的に作業するために、PlayディレクトリにPathを切っておく方がいいでしょう。これで、 **play** とコマンドプロンプトに入力するだけで、playユーティリティを使うことができます。インストールがうまく行っていることを確認するために、 **play** と打ってみましょう。基礎的な使い方についてのヘルプ画面が表示されます。

h2. <a>Scalaモジュールをインストール</a>

ScalaでPlayFrameworkを使うのは簡単で、Scalaモジュールをダウンロードするだけです。 @play install scala@ とコマンドを実行するだけで以下のようにインストール可能です。

bc. $ play install scala
~        _            _ 
~  _ __ | | __ _ _  _| |
~ | '_ \| |/ _' | || |_|
~ |  __/|_|\____|\__ (_)
~ |_|            |__/   
~
~ play! 1.2, http://www.playframework.org
~
~ Will install scala-0.9
~ This module is compatible with: Play 1.2
~ Do you want to install this version (y/n)? y
~ Installing module scala-0.9...
~
~ Fetching http://www.playframework.org/modules/scala-0.9.zip
~ [--------------------------100%-------------------------] 17313.2 KiB/s   
~ Unzipping...
~
~ Module scala-0.9 is installed!

h2. <a>プロジェクト作成</a>

さて、Playを正しくインストールできたので、ブログアプリケーションを作り始めましょう。Playアプリを作るのはとても簡単で、Playコマンドラインのユーティリティで全て管理することができます。これによって、全てのPlayアプリケーションで、標準的なレイアウトが適用されることになるのです。

以下のようにコマンドを入力しましょう。

bc. ~$ play new yabe --with scala

アプリケーションのフルネームを入力するよう求められるので、 **Yet Another Blog Engine** と入力しましょう。

!images/guide1-1!

**play new** コマンドは、yabe/ ディレクトリを作成し、以下の重要なディレクトリやファイルを配置します。

* **app/** ディレクトリは、アプリケーションのコア要素を格納するディレクトリです。 **.scala** ソースファイルが配置されるのもここです。 

* **conf/** ディレクトリは、アプリケーションの全ての設定ファイルが格納されます。メインとなるのは、 **application.conf** ファイルであり、他にも **routes** 定義ファイルや、 **dependencies.yml** ファイル、他言語化に使われる **messages** ファイルなどが格納されます。

* **lib/** ディレクトリには、 **.jar** ファイルとしてパッケージされた、ScalaライブラリやJavaライブラリが格納される。

* **public/** ディレクトリには、パブリックに利用できるリソースを格納する。javascriptファイルや、スタイルシート、画像ファイルなどが含まれる。

* **test/** ディレクトリには、アプリケーションの全てのテストコードが含まれる。テストコードはScalaTest、もしくはSeleniumテストとして記述される。

このように、 **conf/dependencies.yml** という依存性を定義するファイルには、Scalaの依存性が自動的に定義されます

bc. # Application dependencies
 
require:
    - play
    - play -> scala 0.9

p(note). 唯一のエンコーディングとして **PlayはUTF-8を使っている** ため、全ての定義ファイルがUTF-8でエンコーディングされていることが重要になります。適宜、エディタのエンコーディングを設定してください。

さて、熟練のScalaプログラマなら.classファイルはどこに行くのかと考えるでしょう。答えは「どこにも行かない」です。Playは.classファイルを一切使わず、Scalaソースファイルを直接読み込みます。

これは開発過程において、２つの重要な意味を持ちます。ひとつは、Scalaソースファイルの変更を検出し、実行中に自動的に再読み込みする、ということです。ふたつめは、Exceptionが発生した時に、Playは実際のScalaソースコードベースでエラーレポートを表示させることができる、ということです。

実際には、Playは **tmp/** ディレクトリにバイトコードキャッシュを保持しますが、大きなアプリケーションの再起動処理を高速化させるためだけのものです。必要とあらば、 **play clean** コマンドによってキャッシュをクリアすることができます。

h2. <a>アプリケーション稼働</a>

さて、新しく作ったアプリケーションを試してみましょう。 **yabe/** ディレクトリ内で、 **play run** コマンドを実行するだけでOKです。Playはアプリケーションをロードして、9000番ポートでWEBサーバを起動します。

ブラウザでURLを "http://localhost:9000":http://localhost:9000 と指定することで新しいアプリケーションを確認することができます。新しく作ったアプリケーションは、デフォルトのWELCOMEページを用意していて、これが表示されたことで作成がうまくいったことが分かります。

!images/guide1-2!

この新しいアプリケーションがどのようにこのページを表示しているのか見てみましょう。

主な入り口は、 **conf/routes** ファイルになります。このファイルでは、全てのアクセス可能なURLを定義します。生成されたroutesファイルを参照すると、最初の「ルート」を確認することができます。

bc. GET		/			Application.index

これは、単純に、 **/** パスに対する **GET** リクエストを受け取ると、 @Application.index@ アクションメソッドを呼び出すということを意味します。このケースでは、 @Application.index@ は、 @controllers.Application.index@ へのショートカットとなります。controllersパッケージは暗黙的に解決されます。

スタンドアローンのScalaアプリを作る際には、以下のように @main@ メソッドによって入り口を定義されたシングルオブジェクトを一般的には使います。

bc. object Main {
    def main(args: Array[String]) {
        …
    }
}

Playアプリでは、それぞれのURLにくくり付く、いくつかの入り口を持ちます。これを **アクションメソッド** と呼びます。アクションメソッドは、 **コントローラ** という特別なオブジェクトで定義されます。

@controllers.Application@ コントローラがどのようなものか見てみましょう。 **yabe/app/controllers.scala** ソースファイルを開きます。

bc. package controllers
 
import play._
import play.mvc._
 
object Application extends Controller {
    
    import views.Application._
    
    def index = {
        html.index("Your new Scala application is ready!")
    }
    
}

@play.mvc.Controller@ クラスを継承していることに気づくと思います。

このindexアクションは、このオブジェクトの単なるメソッドとして定義されます。これがアクションメソッドの定義方法です。アクションメソッドは、フレームワークによって、純粋なHTTPレスポンスに暗黙的に変換される値を常に返します。

デフォルトのindexアクションはシンプルです。 *views.Application.html.index* を呼び出し、そこから生成されるHTMLを応答します。テンプレートを使うのはHTTPレスポンスを生成するのに最も一般的な方法になります。（唯一の方法ではありません）

テンプレートは、 **/app/views** に配置された、Scalaソースファイルになります。

テンプレートファイルを見てみましょう。 **helloworld/app/views/Application/index.scala.html** を開きます。

bc. @(title:String)
 
@main(title) {
    
    @views.defaults.html.welcome(title)
    
}

テンプレートの中身は実に簡単に見えますね。実際、これは他のテンプレートを呼び出し、Welcomeページを生成しているのです。

一行目はテンプレートの引数を定義しています。 *play.template.Html* を生成する関数をテンプレートとしているという定義になります。この場合、テンプレートはString型の @title@ 引数を持っていて、テンプレートの型は、 @(String) => Html@ となります。

そして、このテンプレートは ２つの引数（ @String@ と @Html@ ブロック）を要求する、 @main@ という別のテンプレートを呼び出します。

mainテンプレートが定義されている、 **helloworld/app/views/main.scala.html** を見てみましょう。

bc. @(title:String = "")(body: => Html)
 
<!DOCTYPE html>
<html>
  <head>
    <title>@title</title>
    <link rel="stylesheet" href="@asset("public/stylesheets/main.css")">
    <link rel="shortcut icon" href="@asset("public/images/favicon.png")">
    <script src="@asset("public/javascripts/jquery-1.5.2.min.js")"></script>
  </head>
  <body>
    @body
  </body>
</html>

ここでも一行目はテンプレートのパラメータを定義しています。 @main@ テンプレートの型は @(String) (Html) => Html@ になります。

コントローラファイルを編集することで、Playフレームワークがどのようにリロードするかを確認することができます。 **yabe/app/controllers.scala** を開いて、間違いを埋め込んでみましょう。

bc. def index = html.index()

ブラウザを開いて、リロードしてみてください。Playフレームワークが変更を反映して、アプリケーションコントローラをリロードしようとしていることが確認できます。しかし埋め込んだ間違いのために、コンパイルエラーになります。

!images/guide1-3!

では、プログラムを修正し、正しく編集しましょう。

bc. def index = {
    Logger.info("Index page has been requested")
    html.index("Your new Scala application is ready!")
}

この時、Playフレームワークはコントローラを正しくリロードし、JVM内の古いコードを置き換えます。 **/** URL宛へのリクエストが発生するたびに、コンソール上に「Index page has been requested」というメッセージが表示されます。

この無駄な行を消して、 **yabe/app/views/Application/index.scala.html** テンプレートを編集し、Welcomeメッセージを置き換えましょう。

bc. @main("Home") {
    
    <h1>A blog will be there</h1>
    
}

テンプレートの引数を削除したので、コントローラを修正します。

bc. def index = {
    html.index()
}

h2. <a>DBのセットアップ</a>

開発を始める前に、もうひとつやらなければならないことがあります。ブログエンジンにはデータベースが必要です。開発用にPlayフレームワークはH2というスタンドアローンのDB管理システムを持っています。きちんとしたDBに切り替える前に、プロジェクトをスタートするには、ベストな手法となります。アプリケーションの再起動をまたいでデータを保持したいか、そうでないかで、ファイルシステムデータベースか、インメモリデータベースかを選ぶことができます。

最初は、モデルを何回も変更したりテストしたりするため、アプリ起動の度にデータをリフレッシュするインメモリデータベースを使うのがいいでしょう。

データベースをセットアップするために、 **yabe/conf/application.conf** を開いて、以下の行のコメントをはずしてください。

bc. db=mem

コメントを見れば分かるように、JDBC接続に簡単に切り替えることができるし、コネクションプールさえ設定することができる。

さて、ブラウザに戻りwelcomeページをリロードしてみましょう。Playフレームワークはデータベースを自動的にスタートさせます。以下のログが出力されることを確認してください。

bc. INFO  ~ Connected to jdbc:h2:mem:play

<hr>

p(note). 次は %(next)"データモデルの最初のイテレーション":guide2%. 

